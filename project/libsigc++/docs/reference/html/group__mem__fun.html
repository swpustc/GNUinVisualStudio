<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>libsigc++: mem_fun()</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsigc++
   &#160;<span id="projectnumber">2.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mem_fun()<div class="ingroups"><a class="el" href="group__sigcfunctors.html">Functors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419" title="Creates a functor of type sigc::mem_functor0 which wraps a method. ">mem_fun()</a> is used to convert a pointer to a method to a functor.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">sigc::bound_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">sigc::bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">sigc::bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">sigc::bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">sigc::bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">sigc::bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">sigc::bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">sigc::bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s). ">const_mem_functor0</a> wraps const methods with 0 argument(s).  <a href="classsigc_1_1const__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s). ">const_mem_functor1</a> wraps const methods with 1 argument(s).  <a href="classsigc_1_1const__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s). ">const_mem_functor2</a> wraps const methods with 2 argument(s).  <a href="classsigc_1_1const__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s). ">const_mem_functor3</a> wraps const methods with 3 argument(s).  <a href="classsigc_1_1const__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s). ">const_mem_functor4</a> wraps const methods with 4 argument(s).  <a href="classsigc_1_1const__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s). ">const_mem_functor5</a> wraps const methods with 5 argument(s).  <a href="classsigc_1_1const__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s). ">const_mem_functor6</a> wraps const methods with 6 argument(s).  <a href="classsigc_1_1const__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s). ">const_mem_functor7</a> wraps const methods with 7 argument(s).  <a href="classsigc_1_1const__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s). ">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s). ">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s). ">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s). ">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s). ">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s). ">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s). ">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s). ">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">mem_functor0</a> wraps methods with 0 argument(s).  <a href="classsigc_1_1mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">mem_functor1</a> wraps methods with 1 argument(s).  <a href="classsigc_1_1mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">mem_functor2</a> wraps methods with 2 argument(s).  <a href="classsigc_1_1mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">mem_functor3</a> wraps methods with 3 argument(s).  <a href="classsigc_1_1mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">mem_functor4</a> wraps methods with 4 argument(s).  <a href="classsigc_1_1mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">mem_functor5</a> wraps methods with 5 argument(s).  <a href="classsigc_1_1mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">mem_functor6</a> wraps methods with 6 argument(s).  <a href="classsigc_1_1mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">mem_functor7</a> wraps methods with 7 argument(s).  <a href="classsigc_1_1mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">sigc::volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s). ">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s).  <a href="classsigc_1_1volatile__mem__functor0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">sigc::volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s). ">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s).  <a href="classsigc_1_1volatile__mem__functor1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">sigc::volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s). ">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s).  <a href="classsigc_1_1volatile__mem__functor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">sigc::volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s). ">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s).  <a href="classsigc_1_1volatile__mem__functor3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">sigc::volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s). ">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s).  <a href="classsigc_1_1volatile__mem__functor4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">sigc::volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s). ">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s).  <a href="classsigc_1_1volatile__mem__functor5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">sigc::volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s). ">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s).  <a href="classsigc_1_1volatile__mem__functor6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">sigc::volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s). ">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s).  <a href="classsigc_1_1volatile__mem__functor7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplItemLeft" align="right" valign="top">mem_functor0&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:gadf6b6d22c503b439019f0a2e77352419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">sigc::mem_functor0</a> which wraps a method.  <a href="#gadf6b6d22c503b439019f0a2e77352419">More...</a><br /></td></tr>
<tr class="separator:gadf6b6d22c503b439019f0a2e77352419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplItemLeft" align="right" valign="top">mem_functor1&lt; T_return, T_obj, <br class="typebreak" />
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab661fef0f04e2e439912eee6989e9657">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gab661fef0f04e2e439912eee6989e9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">sigc::mem_functor1</a> which wraps a method.  <a href="#gab661fef0f04e2e439912eee6989e9657">More...</a><br /></td></tr>
<tr class="separator:gab661fef0f04e2e439912eee6989e9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplItemLeft" align="right" valign="top">mem_functor2&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">sigc::mem_functor2</a> which wraps a method.  <a href="#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">More...</a><br /></td></tr>
<tr class="separator:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplItemLeft" align="right" valign="top">mem_functor3&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa3778234963fa65d4f638856d91109d1">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gaa3778234963fa65d4f638856d91109d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">sigc::mem_functor3</a> which wraps a method.  <a href="#gaa3778234963fa65d4f638856d91109d1">More...</a><br /></td></tr>
<tr class="separator:gaa3778234963fa65d4f638856d91109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplItemLeft" align="right" valign="top">mem_functor4&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadadd40aba6dadd0edbaac609dfae3938">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gadadd40aba6dadd0edbaac609dfae3938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">sigc::mem_functor4</a> which wraps a method.  <a href="#gadadd40aba6dadd0edbaac609dfae3938">More...</a><br /></td></tr>
<tr class="separator:gadadd40aba6dadd0edbaac609dfae3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplItemLeft" align="right" valign="top">mem_functor5&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak" />
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa01df6c622d59cfd2d0d8aa3c04c36d1">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">sigc::mem_functor5</a> which wraps a method.  <a href="#gaa01df6c622d59cfd2d0d8aa3c04c36d1">More...</a><br /></td></tr>
<tr class="separator:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplItemLeft" align="right" valign="top">mem_functor6&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak" />
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9030b647c35e06c68342fee34e8fd320">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga9030b647c35e06c68342fee34e8fd320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">sigc::mem_functor6</a> which wraps a method.  <a href="#ga9030b647c35e06c68342fee34e8fd320">More...</a><br /></td></tr>
<tr class="separator:ga9030b647c35e06c68342fee34e8fd320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplItemLeft" align="right" valign="top">mem_functor7&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak" />
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga54e4bf947e8c93c56931b8e8f7ed0d2e">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">sigc::mem_functor7</a> which wraps a method.  <a href="#ga54e4bf947e8c93c56931b8e8f7ed0d2e">More...</a><br /></td></tr>
<tr class="separator:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak" />
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7f57ec0156d33b4aa98e259d2e2062db">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#ga7f57ec0156d33b4aa98e259d2e2062db">More...</a><br /></td></tr>
<tr class="separator:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak" />
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaeef6e55681664df29b31edec51ea034d">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:gaeef6e55681664df29b31edec51ea034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaeef6e55681664df29b31edec51ea034d">More...</a><br /></td></tr>
<tr class="separator:gaeef6e55681664df29b31edec51ea034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak" />
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0df7af9f32990cc624c4bb60782b4f78">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga0df7af9f32990cc624c4bb60782b4f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga0df7af9f32990cc624c4bb60782b4f78">More...</a><br /></td></tr>
<tr class="separator:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak" />
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7de39a04dfc6d37b2d12a25cdccfbe95">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga7de39a04dfc6d37b2d12a25cdccfbe95">More...</a><br /></td></tr>
<tr class="separator:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga118b2610268701be95cdc6fddb7bab3b">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga118b2610268701be95cdc6fddb7bab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga118b2610268701be95cdc6fddb7bab3b">More...</a><br /></td></tr>
<tr class="separator:ga118b2610268701be95cdc6fddb7bab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab1add5c927b51b935b4f2d40558079fa">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gab1add5c927b51b935b4f2d40558079fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gab1add5c927b51b935b4f2d40558079fa">More...</a><br /></td></tr>
<tr class="separator:gab1add5c927b51b935b4f2d40558079fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaeb6bd4518e0f0c524dba13a6cbb2e319">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#gaeb6bd4518e0f0c524dba13a6cbb2e319">More...</a><br /></td></tr>
<tr class="separator:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1f1aa3b60c0d2d8b2470bba0b2b36023">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga1f1aa3b60c0d2d8b2470bba0b2b36023">More...</a><br /></td></tr>
<tr class="separator:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga02c906c95895c58e39ee301bb1577994">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga02c906c95895c58e39ee301bb1577994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga02c906c95895c58e39ee301bb1577994">More...</a><br /></td></tr>
<tr class="separator:ga02c906c95895c58e39ee301bb1577994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga481ef34d8423d26e8ff0a1916cd295d5">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga481ef34d8423d26e8ff0a1916cd295d5">More...</a><br /></td></tr>
<tr class="separator:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab138ae1a340be983166b69872826b37d">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gab138ae1a340be983166b69872826b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gab138ae1a340be983166b69872826b37d">More...</a><br /></td></tr>
<tr class="separator:gab138ae1a340be983166b69872826b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga09fb13b1684ec7c092ffef695dbb261a">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga09fb13b1684ec7c092ffef695dbb261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga09fb13b1684ec7c092ffef695dbb261a">More...</a><br /></td></tr>
<tr class="separator:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3e3841c4844715d2f2d832ed506f028f">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga3e3841c4844715d2f2d832ed506f028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga3e3841c4844715d2f2d832ed506f028f">More...</a><br /></td></tr>
<tr class="separator:ga3e3841c4844715d2f2d832ed506f028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0d9b992d69123a524b6c70c458ad0d40">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga0d9b992d69123a524b6c70c458ad0d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga0d9b992d69123a524b6c70c458ad0d40">More...</a><br /></td></tr>
<tr class="separator:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaea5a2ace2699b8d1ffe93585e335548d">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gaea5a2ace2699b8d1ffe93585e335548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#gaea5a2ace2699b8d1ffe93585e335548d">More...</a><br /></td></tr>
<tr class="separator:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5dcdaf235baa50049e6088d246853037">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga5dcdaf235baa50049e6088d246853037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga5dcdaf235baa50049e6088d246853037">More...</a><br /></td></tr>
<tr class="separator:ga5dcdaf235baa50049e6088d246853037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplItemLeft" align="right" valign="top">mem_functor0&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga765b35689a909fbc2a627be8256c5b1f">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:ga765b35689a909fbc2a627be8256c5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">sigc::mem_functor0</a> which wraps a method.  <a href="#ga765b35689a909fbc2a627be8256c5b1f">More...</a><br /></td></tr>
<tr class="separator:ga765b35689a909fbc2a627be8256c5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak" />
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae03d0b73b85e85d2ad8bc43b19b855e3">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gae03d0b73b85e85d2ad8bc43b19b855e3">More...</a><br /></td></tr>
<tr class="separator:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak" />
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf71277763f14050e2d270fcf3ea41dc9">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:gaf71277763f14050e2d270fcf3ea41dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaf71277763f14050e2d270fcf3ea41dc9">More...</a><br /></td></tr>
<tr class="separator:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplItemLeft" align="right" valign="top">mem_functor1&lt; T_return, T_obj, <br class="typebreak" />
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae0bebf0d8a2d36d93746c23d9eea668d">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">sigc::mem_functor1</a> which wraps a method.  <a href="#gae0bebf0d8a2d36d93746c23d9eea668d">More...</a><br /></td></tr>
<tr class="separator:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak" />
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3dd8d2ed97310dbf4fa394999f0be7b7">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga3dd8d2ed97310dbf4fa394999f0be7b7">More...</a><br /></td></tr>
<tr class="separator:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak" />
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaade596a4dacfd1429039525bb9f399d0">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gaade596a4dacfd1429039525bb9f399d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#gaade596a4dacfd1429039525bb9f399d0">More...</a><br /></td></tr>
<tr class="separator:gaade596a4dacfd1429039525bb9f399d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplItemLeft" align="right" valign="top">mem_functor2&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab76f41aeada332b353b6fe2e96008831">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gab76f41aeada332b353b6fe2e96008831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">sigc::mem_functor2</a> which wraps a method.  <a href="#gab76f41aeada332b353b6fe2e96008831">More...</a><br /></td></tr>
<tr class="separator:gab76f41aeada332b353b6fe2e96008831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga184da4166c8b5409dc4b98d7bc16dff8">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga184da4166c8b5409dc4b98d7bc16dff8">More...</a><br /></td></tr>
<tr class="separator:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaee7652f1a0625df50af50e28b5e2423e">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gaee7652f1a0625df50af50e28b5e2423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gaee7652f1a0625df50af50e28b5e2423e">More...</a><br /></td></tr>
<tr class="separator:gaee7652f1a0625df50af50e28b5e2423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplItemLeft" align="right" valign="top">mem_functor3&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga2379e0d689fe4a99c7c669fc29817457">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga2379e0d689fe4a99c7c669fc29817457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">sigc::mem_functor3</a> which wraps a method.  <a href="#ga2379e0d689fe4a99c7c669fc29817457">More...</a><br /></td></tr>
<tr class="separator:ga2379e0d689fe4a99c7c669fc29817457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4f2fdbf02e8cac9492326a4a8ffdd012">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga4f2fdbf02e8cac9492326a4a8ffdd012">More...</a><br /></td></tr>
<tr class="separator:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga14e07df139b5cb6897e671c50fc33cde">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga14e07df139b5cb6897e671c50fc33cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga14e07df139b5cb6897e671c50fc33cde">More...</a><br /></td></tr>
<tr class="separator:ga14e07df139b5cb6897e671c50fc33cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplItemLeft" align="right" valign="top">mem_functor4&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1bedd04f76ad3e21f614912562e95d83">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga1bedd04f76ad3e21f614912562e95d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">sigc::mem_functor4</a> which wraps a method.  <a href="#ga1bedd04f76ad3e21f614912562e95d83">More...</a><br /></td></tr>
<tr class="separator:ga1bedd04f76ad3e21f614912562e95d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga94a2525ef116e16598b81b853544a170">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga94a2525ef116e16598b81b853544a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga94a2525ef116e16598b81b853544a170">More...</a><br /></td></tr>
<tr class="separator:ga94a2525ef116e16598b81b853544a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga86da5637e2735480d525ffa930e7e21a">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga86da5637e2735480d525ffa930e7e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga86da5637e2735480d525ffa930e7e21a">More...</a><br /></td></tr>
<tr class="separator:ga86da5637e2735480d525ffa930e7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplItemLeft" align="right" valign="top">mem_functor5&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak" />
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3ef4bb904a751d29e2b6803ef81f72fa">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">sigc::mem_functor5</a> which wraps a method.  <a href="#ga3ef4bb904a751d29e2b6803ef81f72fa">More...</a><br /></td></tr>
<tr class="separator:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">More...</a><br /></td></tr>
<tr class="separator:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5c2ca9cef8c857935a59133a73ef61f2">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga5c2ca9cef8c857935a59133a73ef61f2">More...</a><br /></td></tr>
<tr class="separator:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplItemLeft" align="right" valign="top">mem_functor6&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak" />
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34ace98fbbd18cb635795639d0f22678">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga34ace98fbbd18cb635795639d0f22678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">sigc::mem_functor6</a> which wraps a method.  <a href="#ga34ace98fbbd18cb635795639d0f22678">More...</a><br /></td></tr>
<tr class="separator:ga34ace98fbbd18cb635795639d0f22678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac0a6242da9bf96642f25c1363dfef383">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gac0a6242da9bf96642f25c1363dfef383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#gac0a6242da9bf96642f25c1363dfef383">More...</a><br /></td></tr>
<tr class="separator:gac0a6242da9bf96642f25c1363dfef383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga947f4410e62a2996023177e490c882b7">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga947f4410e62a2996023177e490c882b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga947f4410e62a2996023177e490c882b7">More...</a><br /></td></tr>
<tr class="separator:ga947f4410e62a2996023177e490c882b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplItemLeft" align="right" valign="top">mem_functor7&lt; T_return, T_obj, <br class="typebreak" />
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak" />
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3d174b01bf94dbda3aea58c25c2b3322">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">sigc::mem_functor7</a> which wraps a method.  <a href="#ga3d174b01bf94dbda3aea58c25c2b3322">More...</a><br /></td></tr>
<tr class="separator:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9899534bc8eb78c227d895b396710091">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga9899534bc8eb78c227d895b396710091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga9899534bc8eb78c227d895b396710091">More...</a><br /></td></tr>
<tr class="separator:ga9899534bc8eb78c227d895b396710091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak" />
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak" />
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1f704e475da2aad1717e059c264c1436">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga1f704e475da2aad1717e059c264c1436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga1f704e475da2aad1717e059c264c1436">More...</a><br /></td></tr>
<tr class="separator:ga1f704e475da2aad1717e059c264c1436"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419" title="Creates a functor of type sigc::mem_functor0 which wraps a method. ">mem_fun()</a> is used to convert a pointer to a method to a functor. </p>
<p>Optionally, a reference or pointer to an object can be bound to the functor. Note that only if the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> is the slot automatically cleared when the object goes out of scope!</p>
<p>If the member function pointer is to an overloaded type, you must specify the types using template arguments starting with the first argument. It is not necessary to supply the return type.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>foo : <span class="keyword">public</span> <a class="code" href="structsigc_1_1trackable.html">sigc::trackable</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}</div>
<div class="line">};</div>
<div class="line">foo my_foo;</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun</a>(my_foo, &amp;foo::bar);</div>
</div><!-- fragment --></dd></dl>
<p>For const methods <a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419" title="Creates a functor of type sigc::mem_functor0 which wraps a method. ">mem_fun()</a> takes a const reference or pointer to an object.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>foo : <span class="keyword">public</span> <a class="code" href="structsigc_1_1trackable.html">sigc::trackable</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> foo my_foo;</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun</a>(my_foo, &amp;foo::bar);</div>
</div><!-- fragment --></dd></dl>
<p>Use mem_fun#() if there is an ambiguity as to the number of arguments.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>foo : <span class="keyword">public</span> <a class="code" href="structsigc_1_1trackable.html">sigc::trackable</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">float</span>) {}</div>
<div class="line">  <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {}</div>
<div class="line">};</div>
<div class="line">foo my_foo;</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = sigc::mem_fun1&lt;int&gt;(my_foo, &amp;foo::bar);</div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gadf6b6d22c503b439019f0a2e77352419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">sigc::mem_functor0</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab661fef0f04e2e439912eee6989e9657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">sigc::mem_functor1</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">sigc::mem_functor2</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3778234963fa65d4f638856d91109d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">sigc::mem_functor3</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadadd40aba6dadd0edbaac609dfae3938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">sigc::mem_functor4</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa01df6c622d59cfd2d0d8aa3c04c36d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">sigc::mem_functor5</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9030b647c35e06c68342fee34e8fd320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">sigc::mem_functor6</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54e4bf947e8c93c56931b8e8f7ed0d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">sigc::mem_functor7</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f57ec0156d33b4aa98e259d2e2062db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeef6e55681664df29b31edec51ea034d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0df7af9f32990cc624c4bb60782b4f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7de39a04dfc6d37b2d12a25cdccfbe95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga118b2610268701be95cdc6fddb7bab3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1add5c927b51b935b4f2d40558079fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb6bd4518e0f0c524dba13a6cbb2e319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f1aa3b60c0d2d8b2470bba0b2b36023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02c906c95895c58e39ee301bb1577994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga481ef34d8423d26e8ff0a1916cd295d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab138ae1a340be983166b69872826b37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09fb13b1684ec7c092ffef695dbb261a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e3841c4844715d2f2d832ed506f028f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d9b992d69123a524b6c70c458ad0d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea5a2ace2699b8d1ffe93585e335548d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dcdaf235baa50049e6088d246853037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga765b35689a909fbc2a627be8256c5b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">sigc::mem_functor0</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae03d0b73b85e85d2ad8bc43b19b855e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf71277763f14050e2d270fcf3ea41dc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0bebf0d8a2d36d93746c23d9eea668d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">sigc::mem_functor1</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dd8d2ed97310dbf4fa394999f0be7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaade596a4dacfd1429039525bb9f399d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab76f41aeada332b353b6fe2e96008831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">sigc::mem_functor2</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga184da4166c8b5409dc4b98d7bc16dff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee7652f1a0625df50af50e28b5e2423e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2379e0d689fe4a99c7c669fc29817457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">sigc::mem_functor3</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2fdbf02e8cac9492326a4a8ffdd012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14e07df139b5cb6897e671c50fc33cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bedd04f76ad3e21f614912562e95d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">sigc::mem_functor4</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94a2525ef116e16598b81b853544a170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86da5637e2735480d525ffa930e7e21a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ef4bb904a751d29e2b6803ef81f72fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">sigc::mem_functor5</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf060fe3a2be4ff7c0f50aef54b4dc8bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c2ca9cef8c857935a59133a73ef61f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34ace98fbbd18cb635795639d0f22678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">sigc::mem_functor6</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0a6242da9bf96642f25c1363dfef383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga947f4410e62a2996023177e490c882b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d174b01bf94dbda3aea58c25c2b3322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">sigc::mem_functor7</a> which wraps a method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9899534bc8eb78c227d895b396710091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f704e475da2aad1717e059c264c1436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 15 2014 15:59:58 for libsigc++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
